//
// Created by Lars Schwarz on 04.10.2023.
//

#include "comms.h"
#include <iostream>

CommsMaster::CommsMaster(comms_packet_t* prx_data, comms_packet_t* ptx_data, robocar_data_t* pdata_) {
  prx_packet = prx_data;
  ptx_packet = ptx_data;
  pdata = pdata_;
}

uint8_t CommsMaster::checksum(const uint8_t *data_, uint16_t length) {
  uint8_t sum = 0;
  for (uint16_t i = 0; i < length; ++i) {
    sum += data_[i];
  }
  return sum;
}

uint8_t CommsMaster::bitMask(uint8_t lower, uint8_t upper) {
  uint8_t value = 0;
  for (uint8_t i=lower; i<=upper; i++)
    value |= 1 << i;
  return value;
}


uint8_t CommsMaster::receive() {
  std::cout << "Master: RX-PART\n";
  std::cout << "rx_header: ";
  for (uint32_t i = 0; i < sizeof(comms_packet_header_t); ++i) {
    std::cout << rx_packet->header.buffer[i];
  }
  std::cout << std::endl;

  std::cout << "rx_packet: ";
  for (uint32_t i = 0; i < MAX_DATA_LENGTH; ++i) {
    std::cout << rx_packet->data.buffer[i];
  }
  std::cout <<"" << std::endl;

  std::cout <<"rx_package sync is: 0x" << rx_packet->header.sync << std::endl;
  std::cout <<"rx_package access request is: " << rx_packet->header.access_request << std::endl;
  std::cout <<"rx_package is " << rx_packet->header.package_length << "bytes long" << std::endl;
  std::cout <<"rx_package checksum is: " << rx_packet->header.checksum << std::endl;

  // Validate the received package
  uint16_t rx_packet_calculated_checksum = checksum(rx_packet->data.buffer, rx_packet->header.package_length);
  if (rx_packet->header.sync == SYNC ||
      rx_packet->header.checksum == rx_packet_calculated_checksum) {
    uint16_t rx_index = 0;
    // Coppy the valid data witch was generated by the access request from the last cycle into the local ram
    if (last_access_request.state == COMMS_ACCESS_REQUEST_GET) {
      memcpy(&data->state, &rx_packet->data.buffer[rx_index], sizeof(state_t));
      rx_index += sizeof(state_t);
    }
    if (last_access_request.sensor == COMMS_ACCESS_REQUEST_GET) {
      memcpy(&data->sensor, &rx_packet->data.buffer[rx_index], sizeof(sensor_t));
      rx_index += sizeof(sensor_t);
    }
    if (last_access_request.data == COMMS_ACCESS_REQUEST_GET) {
      memcpy(&data->data, &rx_packet->data.buffer[rx_index], sizeof(data_t));
      rx_index += sizeof(data_t);
    }
    if (last_access_request.parameter == COMMS_ACCESS_REQUEST_GET) {
      memcpy(&data->parameter, &rx_packet->data.buffer[rx_index], sizeof(parameter_t));
      rx_index += sizeof(parameter_t);
    }
    if (last_access_request.request == COMMS_ACCESS_REQUEST_GET) {
      memcpy(&data->request, &rx_packet->data.buffer[rx_index], sizeof(request_t));
      rx_index += sizeof(request_t);
    }
    std::cout <<"RX-PART SUCCESSFUL \n" << std::endl;
  } else {
    std::cout <<"Dropping curren package... Package is corrupted.";
    if (rx_packet->header.sync != SYNC) std::cout <<" SYNC byte is invalid";
    if (rx_packet->header.checksum != rx_packet_calculated_checksum)
      std::cout <<" Checksum is wrong got: " << rx_packet_calculated_checksum << " expected: " << rx_packet->header.checksum << std::endl;
  }

  return EXIT_SUCCESS;
}

uint8_t CommsMaster::transmit() {
  return EXIT_SUCCESS;
}




CommsSlave::CommsSlave(comms_packet_t *prx_data, comms_packet_t *ptx_data, robocar_data_t* pdata_) {
  prx_packet = prx_data;
  ptx_packet = ptx_data;
  pdata = pdata_;
}

uint8_t CommsSlave::checksum(const uint8_t *data_, uint16_t length) {
  uint8_t sum = 0;
  for (uint16_t i = 0; i < length; ++i) {
    sum += data_[i];
  }
  return sum;
}

uint8_t CommsSlave::bitMask(uint8_t lower, uint8_t upper) {
  uint8_t value = 0;
  for (uint8_t i=lower; i<=upper; i++)
    value |= 1 << i;
  return value;
}


uint8_t CommsSlave::receive() {
  return EXIT_SUCCESS;
}

uint8_t CommsSlave::transmit() {
  return EXIT_SUCCESS;
}
